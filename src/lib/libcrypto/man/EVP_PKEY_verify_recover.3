.Dd $Mdocdate: November 3 2016 $
.Dt EVP_PKEY_VERIFY_RECOVER 3
.Os
.Sh NAME
.Nm EVP_PKEY_verify_recover_init ,
.Nm EVP_PKEY_verify_recover
.Nd recover signature using a public key algorithm
.Sh SYNOPSIS
.In openssl/evp.h
.Ft int
.Fo EVP_PKEY_verify_recover_init
.Fa "EVP_PKEY_CTX *ctx"
.Fc
.Ft int
.Fo EVP_PKEY_verify_recover
.Fa "EVP_PKEY_CTX *ctx"
.Fa "unsigned char *rout"
.Fa "size_t *routlen"
.Fa "const unsigned char *sig"
.Fa "size_t siglen"
.Fc
.Sh DESCRIPTION
The
.Fn EVP_PKEY_verify_recover_init
function initializes a public key algorithm context using key
.Fa ctx->pkey
for a verify recover operation.
.Pp
The
.Fn EVP_PKEY_verify_recover
function recovers signed data using
.Fa ctx .
The signature is specified using the
.Fa sig
and
.Fa siglen
parameters.
If
.Fa rout
is
.Dv NULL ,
then the maximum size of the output buffer is written to the
.Fa routlen
parameter.
If
.Fa rout
is not
.Dv NULL ,
then before the call the
.Fa routlen
parameter should contain the length of the
.Fa rout
buffer.
If the call is successful, recovered data is written to
.Fa rout
and the amount of data written to
.Fa routlen .
.Pp
Normally an application is only interested in whether a signature
verification operation is successful.
In those cases, the
.Xr EVP_verify 3
function should be used.
.Pp
Sometimes however it is useful to obtain the data originally signed
using a signing operation.
Only certain public key algorithms can recover a signature in this way
(for example RSA in PKCS padding mode).
.Pp
After the call to
.Fn EVP_PKEY_verify_recover_init ,
algorithm specific control operations can be performed to set any
appropriate parameters for the operation.
.Pp
The function
.Fn EVP_PKEY_verify_recover
can be called more than once on the same context if several operations
are performed using the same parameters.
.Sh RETURN VALUES
.Fn EVP_PKEY_verify_recover_init
and
.Fn EVP_PKEY_verify_recover
return 1 for success and 0 or a negative value for failure.
In particular, a return value of -2 indicates the operation is not
supported by the public key algorithm.
.Sh EXAMPLES
Recover digest originally signed using PKCS#1 and SHA256 digest:
.Bd -literal
#include <openssl/evp.h>
#include <openssl/rsa.h>

EVP_PKEY_CTX *ctx;
unsigned char *rout, *sig;
size_t routlen, siglen;
EVP_PKEY *verify_key;
/* NB: assumes verify_key, sig and siglen are already set up
 * and that verify_key is an RSA public key
 */
ctx = EVP_PKEY_CTX_new(verify_key);
if (!ctx)
	/* Error occurred */
if (EVP_PKEY_verify_recover_init(ctx) <= 0)
	/* Error */
if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PADDING) <= 0)
	/* Error */
if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha256()) <= 0)
	/* Error */

/* Determine buffer length */
if (EVP_PKEY_verify_recover(ctx, NULL, &routlen, sig, siglen) <= 0)
	/* Error */

rout = malloc(routlen);

if (!rout)
	/* malloc failure */

if (EVP_PKEY_verify_recover(ctx, rout, &routlen, sig, siglen) <= 0)
	/* Error */

/* Recovered data is routlen bytes written to buffer rout */
.Ed
.Sh SEE ALSO
.Xr EVP_PKEY_CTX_new 3 ,
.Xr EVP_PKEY_encrypt 3 ,
.Xr EVP_PKEY_decrypt 3 ,
.Xr EVP_PKEY_sign 3 ,
.Xr EVP_PKEY_verify 3 ,
.Xr EVP_PKEY_derive 3
.Sh HISTORY
These functions were first added to OpenSSL 1.0.0.
